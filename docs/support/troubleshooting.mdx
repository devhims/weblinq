---
title: 'Troubleshooting Guide'
description: 'Solve common issues and debug problems with the WebLinq API'
---

# Troubleshooting Guide

This guide helps you diagnose and fix common issues when using the WebLinq API.

## Common Issues

### Authentication Problems

<AccordionGroup>
<Accordion title="Invalid API Key (401)" icon="key">
  If you're getting a 401 error:

```json
{
  "error": {
    "code": "invalid_auth",
    "message": "Invalid API key provided"
  }
}
```

**Solution Steps:**

1. Check your API key format
2. Verify the key in your [dashboard](https://weblinq.dev/dashboard/api-keys)
3. Ensure proper header format:
   ```javascript
   headers: {
     'Authorization': 'Bearer YOUR_API_KEY'
   }
   ```

  <Tip>
  Use environment variables to manage API keys securely.
  </Tip>
</Accordion>

<Accordion title="Permission Denied (403)" icon="lock">
  If you're getting a 403 error:

```json
{
  "error": {
    "code": "permission_denied",
    "message": "Your API key doesn't have permission for this operation"
  }
}
```

**Solution Steps:**

1. Check your subscription plan limits
2. Verify API key permissions
3. Consider upgrading your plan

  <Note>
  Some endpoints are only available on higher-tier plans.
  </Note>
</Accordion>
</AccordionGroup>

### Rate Limiting

<AccordionGroup>
<Accordion title="Rate Limit Exceeded (429)" icon="gauge-high">
  If you're hitting rate limits:

```json
{
  "error": {
    "code": "rate_limit_exceeded",
    "message": "Too many requests"
  }
}
```

**Solution Steps:**

1.  Implement exponential backoff:

    ```javascript
    async function makeRequest(url, maxRetries = 3) {
      for (let i = 0; i < maxRetries; i++) {
        try {
          const response = await fetch(url, {
            headers: { Authorization: 'Bearer YOUR_API_KEY' },
          });

          if (response.status === 429) {
            const retryAfter = response.headers.get('Retry-After');
            await sleep(retryAfter * 1000);
            continue;
          }

          return await response.json();
        } catch (error) {
          if (i === maxRetries - 1) throw error;
          await sleep(Math.pow(2, i) * 1000);
        }
      }
    }
    ```

2.  Use rate limit headers:

    ```javascript
    const rateLimit = {
      limit: response.headers.get('X-RateLimit-Limit'),
      remaining: response.headers.get('X-RateLimit-Remaining'),
      reset: response.headers.get('X-RateLimit-Reset'),
    };
    ```

3.  Implement request queuing:
    ```javascript
    class RequestQueue {
    constructor(rateLimit = 60) {
    this.queue = [];
    this.rateLimit = rateLimit;
    this.processing = false;
    }
           async add(request) {
             return new Promise((resolve, reject) => {
               this.queue.push({ request, resolve, reject });
               if (!this.processing) this.process();
             });
           }

           async process() {
             this.processing = true;
             while (this.queue.length > 0) {
               const { request, resolve, reject } = this.queue.shift();
               try {
                 const result = await request();
                 resolve(result);
               } catch (error) {
                 reject(error);
               }
               await sleep(1000 / this.rateLimit);
             }
             this.processing = false;
           }
         }
         ```
    </Accordion>

<Accordion title="Optimizing Request Patterns" icon="chart-line">
  Tips for managing rate limits effectively:

1. **Batch Requests**:

   ```javascript
   // Instead of this:
   for (const url of urls) {
     await makeRequest(url);
   }

   // Do this:
   const batchSize = 10;
   for (let i = 0; i < urls.length; i += batchSize) {
     const batch = urls.slice(i, i + batchSize);
     await Promise.all(batch.map((url) => makeRequest(url)));
     await sleep(1000); // Rate limit pause
   }
   ```

2. **Implement Caching**:

   ```javascript
   const cache = new Map();

   async function cachedRequest(url, ttl = 3600000) {
     const cached = cache.get(url);
     if (cached && Date.now() - cached.timestamp < ttl) {
       return cached.data;
     }

     const data = await makeRequest(url);
     cache.set(url, {
       data,
       timestamp: Date.now(),
     });
     return data;
   }
   ```

3. **Use Webhooks** for long-running operations:
   `javascript
     const job = await fetch('https://api.weblinq.dev/v1/jobs', {
       method: 'POST',
       headers: {
         'Authorization': 'Bearer YOUR_API_KEY',
         'Content-Type': 'application/json'
       },
       body: JSON.stringify({
         urls: ['https://example.com'],
         webhook: 'https://your-server.com/webhook'
       })
     });
     `
   </Accordion>
</AccordionGroup>

### Content Extraction Issues

<AccordionGroup>
<Accordion title="Missing Content" icon="magnifying-glass">
  If content isn't being extracted:

1. **Check Selectors**:

   ```javascript
   // Instead of single selector
   selectors: {
     content: '.main-content';
   }

   // Try multiple fallbacks
   selectors: {
     content: ['.main-content', 'article', '#content', 'main'];
   }
   ```

2. **Wait for Content**:

   ```javascript
   {
     "wait_until": "networkidle0",
     "wait_for": ".dynamic-content",
     "timeout": 10000
   }
   ```

3. **Debug with Screenshots**:
   `javascript
     {
       "debug": true,
       "screenshot": {
         "fullPage": true,
         "highlight": ".main-content"
       }
     }
     `
   </Accordion>

<Accordion title="JavaScript Issues" icon="js">
  For JavaScript-heavy sites:

1. **Enable JavaScript**:

   ```javascript
   {
     "javascript": true,
     "wait_time": 5000,
     "wait_until": "networkidle0"
   }
   ```

2. **Handle Dynamic Loading**:

   ```javascript
   {
     "javascript": true,
     "evaluateAfter": `
       // Wait for specific condition
       await new Promise(resolve => {
         const check = () => {
           if (document.querySelector('.loaded')) {
             resolve();
           } else {
             setTimeout(check, 100);
           }
         };
         check();
       });
     `
   }
   ```

3. **Custom Triggers**:
   `javascript
     {
       "triggers": [
         {
           "event": "click",
           "selector": ".load-more"
         },
         {
           "wait": 1000
         },
         {
           "event": "scroll",
           "to": "bottom"
         }
       ]
     }
     `
   </Accordion>

<Accordion title="Encoding Issues" icon="font">
  If you're seeing garbled text:

1. **Specify Encoding**:

   ```javascript
   {
     "encoding": "utf-8",
     "forceEncoding": true
   }
   ```

2. **Handle Special Characters**:

   ```javascript
   {
     "clean": true,
     "normalize": true
   }
   ```

3. **Custom Character Mapping**:
   `javascript
     {
       "characterMap": {
         "â": "a",
         "ê": "e",
         "î": "i"
       }
     }
     `
   </Accordion>
</AccordionGroup>

### Network & Timeout Issues

<AccordionGroup>
<Accordion title="Request Timeouts" icon="clock">
  If requests are timing out:

1. **Adjust Timeouts**:

   ```javascript
   {
     "timeout": 30000,
     "waitUntil": {
       "networkidle0": true,
       "timeout": 20000
     }
   }
   ```

2. **Progressive Loading**:

   ```javascript
   {
     "progressive": true,
     "checkInterval": 1000,
     "minContent": 100
   }
   ```

3. **Retry Logic**:
   `javascript
     async function fetchWithRetry(url, maxRetries = 3) {
       for (let i = 0; i < maxRetries; i++) {
         try {
           return await fetch(url);
         } catch (error) {
           if (i === maxRetries - 1) throw error;
           await sleep(Math.pow(2, i) * 1000);
         }
       }
     }
     `
   </Accordion>

<Accordion title="Network Errors" icon="wifi">
  For network-related issues:

1. **Handle Connection Errors**:

   ```javascript
   try {
     const response = await fetch(url);
   } catch (error) {
     if (error.code === 'ECONNREFUSED') {
       // Handle connection refused
     } else if (error.code === 'ETIMEDOUT') {
       // Handle timeout
     }
   }
   ```

2. **Proxy Configuration**:

   ```javascript
   {
     "proxy": {
       "server": "proxy.example.com",
       "auth": {
         "username": "user",
         "password": "pass"
       }
     }
   }
   ```

3. **Custom DNS**:
   `javascript
     {
       "dns": {
         "servers": ["8.8.8.8", "8.8.4.4"]
       }
     }
     `
   </Accordion>
</AccordionGroup>

## Advanced Debugging

### Logging & Monitoring

<AccordionGroup>
<Accordion title="Request Logging" icon="rectangle-terminal">
  Implement comprehensive logging:

```javascript
async function loggedRequest(url, options = {}) {
  const startTime = Date.now();
  const requestId = Math.random().toString(36).substring(7);

  console.log(`[${requestId}] Starting request to ${url}`);

  try {
    const response = await fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        'X-Request-ID': requestId,
      },
    });

    const duration = Date.now() - startTime;
    console.log(`[${requestId}] Request completed in ${duration}ms`);

    return response;
  } catch (error) {
    console.error(`[${requestId}] Request failed:`, error);
    throw error;
  }
}
```

  <Tip>
  Include request IDs in all error reports for easier debugging.
  </Tip>
</Accordion>

<Accordion title="Performance Monitoring" icon="gauge">
  Track API performance:

```javascript
class APIMonitor {
  constructor() {
    this.metrics = {
      requests: 0,
      errors: 0,
      totalTime: 0,
    };
  }

  async trackRequest(fn) {
    const start = Date.now();
    this.metrics.requests++;

    try {
      const result = await fn();
      this.metrics.totalTime += Date.now() - start;
      return result;
    } catch (error) {
      this.metrics.errors++;
      throw error;
    }
  }

  getStats() {
    return {
      ...this.metrics,
      avgTime: this.metrics.totalTime / this.metrics.requests,
      errorRate: this.metrics.errors / this.metrics.requests,
    };
  }
}
```

</Accordion>
</AccordionGroup>

### Error Recovery

<AccordionGroup>
<Accordion title="Circuit Breaker" icon="shield-halved">
  Implement circuit breaker pattern:

```javascript
class CircuitBreaker {
  constructor(fn, options = {}) {
    this.fn = fn;
    this.failures = 0;
    this.maxFailures = options.maxFailures || 5;
    this.resetTimeout = options.resetTimeout || 60000;
    this.state = 'CLOSED';
  }

  async execute(...args) {
    if (this.state === 'OPEN') {
      throw new Error('Circuit breaker is OPEN');
    }

    try {
      const result = await this.fn(...args);
      this.failures = 0;
      return result;
    } catch (error) {
      this.failures++;

      if (this.failures >= this.maxFailures) {
        this.state = 'OPEN';
        setTimeout(() => {
          this.state = 'CLOSED';
          this.failures = 0;
        }, this.resetTimeout);
      }

      throw error;
    }
  }
}
```

</Accordion>

<Accordion title="Fallback Strategies" icon="arrow-rotate-left">
  Implement fallback mechanisms:

```javascript
async function extractWithFallback(url) {
  // Try primary method
  try {
    return await extract(url, { method: 'primary' });
  } catch (error) {
    console.warn('Primary extraction failed, trying fallback');

    // Try secondary method
    try {
      return await extract(url, { method: 'secondary' });
    } catch (error) {
      console.warn('Secondary extraction failed, using basic method');

      // Final fallback
      return await extract(url, { method: 'basic' });
    }
  }
}
```

</Accordion>
</AccordionGroup>

## Getting Help

If you're still experiencing issues:

<CardGroup cols={2}>
  <Card title="Join our Discord" icon="discord" href="https://discord.gg/weblinq">
    Get help from the community and share your projects
  </Card>
  <Card title="Contact Support" icon="envelope" href="mailto:support@weblinq.dev">
    Our team is ready to help with any questions
  </Card>
</CardGroup>

<Note>
  When contacting support, always include: - Your request ID - API response (including headers) - Code sample
  demonstrating the issue - Steps to reproduce
</Note>{' '}
