---
title: Authentication
description: 'Secure your API requests with proper authentication and API key management'
---

## How authentication works

Weblinq uses API key authentication to secure all requests. Every API call must include a valid API key in the request headers, which identifies your account and tracks usage.

<Info>
  All endpoints except health checks require authentication. This ensures your usage is tracked and your data remains
  secure.
</Info>

## Get your API key

<Steps>
<Step title="Create your account">
  Sign up at [weblinq.dev](https://weblinq.dev) - it's free to get started.
  
  <Check>
  Look for the confirmation email to verify your account.
  </Check>
</Step>

<Step title="Access the dashboard">
  Navigate to the API Keys section in your dashboard after logging in.
  <Tip>You can create multiple API keys for different projects or environments.</Tip>
</Step>

<Step title="Generate your key">
  Click "Create API Key" and give it a descriptive name like "Production App" or "Development Testing".
  <Warning>Copy your API key immediately - you won't be able to see it again after creation.</Warning>
</Step>

<Step title="Store securely">
  Save your API key in a secure location like environment variables or a secrets manager.
  
  ```bash
  export WEBLINQ_API_KEY="wq_your_api_key_here"
  ```
  
  <Check>
  Never commit API keys to version control or include them in client-side code.
  </Check>
</Step>
</Steps>

## Authentication methods

### Bearer token (recommended)

Include your API key in the `Authorization` header with the `Bearer` scheme:

<CodeGroup>

```bash cURL
curl -H "Authorization: Bearer $WEBLINQ_API_KEY" \
  "https://api.weblinq.dev/v1/web/scrape"
```

```javascript JavaScript
const response = await fetch('https://api.weblinq.dev/v1/web/scrape', {
  headers: {
    Authorization: `Bearer ${process.env.WEBLINQ_API_KEY}`,
    'Content-Type': 'application/json',
  },
});
```

```python Python
import requests
import os

headers = {
    'Authorization': f'Bearer {os.getenv("WEBLINQ_API_KEY")}',
    'Content-Type': 'application/json'
}

response = requests.post(
    'https://api.weblinq.dev/v1/web/scrape',
    headers=headers,
    json={'url': 'https://example.com'}
)
```

</CodeGroup>

### API key header

Alternatively, you can pass your API key using the `X-API-Key` header:

<CodeGroup>

```bash cURL
curl -H "X-API-Key: $WEBLINQ_API_KEY" \
  "https://api.weblinq.dev/v1/web/scrape"
```

```javascript JavaScript
const response = await fetch('https://api.weblinq.dev/v1/web/scrape', {
  headers: {
    'X-API-Key': process.env.WEBLINQ_API_KEY,
    'Content-Type': 'application/json',
  },
});
```

```python Python
headers = {
    'X-API-Key': os.getenv('WEBLINQ_API_KEY'),
    'Content-Type': 'application/json'
}
```

</CodeGroup>

<Tip>
  Use the `Authorization: Bearer` method when possible - it's the standard approach and works with most HTTP clients and
  libraries.
</Tip>

## Complete examples

### Secure JavaScript implementation

```javascript
class WeblinqClient {
  constructor(apiKey) {
    if (!apiKey) {
      throw new Error('API key is required');
    }
    this.apiKey = apiKey;
    this.baseUrl = 'https://api.weblinq.dev/v1';
  }

  async makeRequest(endpoint, options = {}) {
    const url = `${this.baseUrl}${endpoint}`;
    const config = {
      method: 'POST',
      headers: {
        Authorization: `Bearer ${this.apiKey}`,
        'Content-Type': 'application/json',
        ...options.headers,
      },
      ...options,
    };

    try {
      const response = await fetch(url, config);

      if (!response.ok) {
        const error = await response.json().catch(() => ({}));
        throw new Error(`API Error: ${error.error || response.statusText} (${response.status})`);
      }

      return await response.json();
    } catch (error) {
      if (error.message.includes('401')) {
        throw new Error('Invalid API key. Please check your authentication.');
      }
      throw error;
    }
  }

  async scrape(url, options = {}) {
    return this.makeRequest('/web/scrape', {
      body: JSON.stringify({ url, ...options }),
    });
  }
}

// Usage
const client = new WeblinqClient(process.env.WEBLINQ_API_KEY);
const result = await client.scrape('https://example.com');
```

### Secure Python implementation

```python
import os
import requests
from typing import Dict, Any, Optional

class WeblinqClient:
    def __init__(self, api_key: Optional[str] = None):
        self.api_key = api_key or os.getenv('WEBLINQ_API_KEY')
        if not self.api_key:
            raise ValueError('API key is required. Set WEBLINQ_API_KEY environment variable.')

        self.base_url = 'https://api.weblinq.dev/v1'
        self.session = requests.Session()
        self.session.headers.update({
            'Authorization': f'Bearer {self.api_key}',
            'Content-Type': 'application/json'
        })

    def _make_request(self, endpoint: str, data: Dict[str, Any]) -> Dict[str, Any]:
        """Make a request to the Weblinq API with error handling."""
        url = f'{self.base_url}{endpoint}'

        try:
            response = self.session.post(url, json=data, timeout=30)

            if response.status_code == 401:
                raise ValueError('Invalid API key. Please check your authentication.')
            elif response.status_code == 429:
                raise ValueError('Rate limit exceeded. Please wait before retrying.')
            elif response.status_code == 422:
                raise ValueError('Invalid request. Please check your parameters.')

            response.raise_for_status()
            result = response.json()

            if not result.get('success', False):
                raise ValueError(f"API Error: {result.get('error', 'Unknown error')}")

            return result

        except requests.exceptions.Timeout:
            raise ValueError('Request timed out. Please try again.')
        except requests.exceptions.ConnectionError:
            raise ValueError('Connection failed. Please check your internet connection.')

    def scrape(self, url: str, **options) -> Dict[str, Any]:
        """Extract content from a webpage."""
        data = {'url': url, **options}
        return self._make_request('/web/scrape', data)

# Usage
client = WeblinqClient()
result = client.scrape('https://example.com', format='text')
```

## Error responses

When authentication fails, you'll receive these error responses:

<ResponseExample>
```json Unauthorized (401)
{
  "error": "Invalid API key provided",
  "details": "The API key is missing, invalid, or has been revoked"
}
```
</ResponseExample>

<ResponseExample>
```json Forbidden (403)
{
  "error": "Insufficient permissions",
  "details": "Your API key doesn't have access to this endpoint"
}
```
</ResponseExample>

<ResponseExample>
```json Rate Limited (429)
{
  "error": "Rate limit exceeded",
  "details": "You have exceeded your request limit. Please wait before making more requests.",
  "retryAfter": 60
}
```
</ResponseExample>

## Rate limits and quotas

Your API key has different limits based on your plan:

| Plan           | Requests per hour | Concurrent requests | Features                         |
| -------------- | ----------------- | ------------------- | -------------------------------- |
| **Free**       | 100               | 2                   | All endpoints, basic support     |
| **Pro**        | 10,000            | 10                  | All endpoints, priority support  |
| **Enterprise** | Custom            | Custom              | All endpoints, dedicated support |

### Rate limit headers

Every response includes rate limit information:

```http
X-RateLimit-Limit: 10000
X-RateLimit-Remaining: 9999
X-RateLimit-Reset: 1642694400
X-RateLimit-Window: 3600
```

## Security best practices

### Environment variables

Always store API keys in environment variables:

<Tabs>
<Tab title="Node.js">
```bash
# .env file
WEBLINQ_API_KEY=wq_your_api_key_here

# In your application

const apiKey = process.env.WEBLINQ_API_KEY;

````
</Tab>

<Tab title="Python">
```bash
# .env file or export
export WEBLINQ_API_KEY=wq_your_api_key_here

# In your application
import os
api_key = os.getenv('WEBLINQ_API_KEY')
````

</Tab>

<Tab title="Docker">
```dockerfile
# Pass as environment variable
docker run -e WEBLINQ_API_KEY=wq_your_api_key_here your-app

# Or use docker-compose with .env file

environment:

- WEBLINQ_API_KEY=${WEBLINQ_API_KEY}

````
</Tab>
</Tabs>

### Additional security measures

<AccordionGroup>
<Accordion title="Rotate keys regularly">
  Create new API keys every 90 days and delete old ones. Use descriptive names to track which keys are used where.
</Accordion>

<Accordion title="Use different keys per environment">
  Create separate API keys for development, staging, and production to limit exposure if a key is compromised.
</Accordion>

<Accordion title="Monitor usage">
  Check your dashboard regularly for unusual activity or unexpected usage patterns that might indicate a compromised key.
</Accordion>

<Accordion title="Restrict by IP (Enterprise)">
  Enterprise plans can restrict API keys to specific IP addresses or CIDR ranges for additional security.
</Accordion>
</AccordionGroup>

<Warning>
**Never do this:** Don't commit API keys to Git, share them in chat/email, embed them in client-side code, or use them in URLs or query parameters.
</Warning>

## Testing your authentication

Verify your setup with a simple test request:

<CodeGroup>

```bash Test with cURL
curl -H "Authorization: Bearer $WEBLINQ_API_KEY" \
  "https://api.weblinq.dev/v1/user/me"
````

```javascript Test with JavaScript
async function testAuth() {
  try {
    const response = await fetch('https://api.weblinq.dev/v1/user/me', {
      headers: {
        Authorization: `Bearer ${process.env.WEBLINQ_API_KEY}`,
      },
    });

    if (response.ok) {
      const user = await response.json();
      console.log('✅ Authentication successful:', user.data.email);
    } else {
      console.error('❌ Authentication failed:', response.status);
    }
  } catch (error) {
    console.error('❌ Request failed:', error.message);
  }
}

testAuth();
```

```python Test with Python
import requests
import os

def test_auth():
    try:
        response = requests.get(
            'https://api.weblinq.dev/v1/user/me',
            headers={'Authorization': f'Bearer {os.getenv("WEBLINQ_API_KEY")}'},
            timeout=10
        )

        if response.ok:
            user = response.json()
            print(f"✅ Authentication successful: {user['data']['email']}")
        else:
            print(f"❌ Authentication failed: {response.status_code}")

    except Exception as error:
        print(f"❌ Request failed: {error}")

test_auth()
```

</CodeGroup>

<Check>
  If authentication is working correctly, you'll see your account email in the response. If not, double-check your API
  key and network connection.
</Check>

## Need help?

<CardGroup cols={2}>
  <Card title="API Key Management" icon="key" href="/api-reference/api-keys/overview">
    Learn how to create, list, and delete API keys
  </Card>
  <Card title="Error Handling" icon="shield-check" href="/api-reference/errors">
    Complete guide to handling authentication errors
  </Card>
</CardGroup>
