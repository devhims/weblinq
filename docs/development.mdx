---
title: 'Development Guide'
description: 'Learn how to develop applications with the WebLinq API'
---

# Development Guide

Learn best practices for developing applications with the WebLinq API.

## Getting Started

<Note>
  Make sure you have your API key ready. If you haven't already, get your API key from the
  [dashboard](https://weblinq.dev/dashboard/api-keys).
</Note>

## Environment Setup

### API Key Management

<CodeGroup>
```javascript Node.js
// .env
WEBLINQ_API_KEY=your_api_key_here

// config.js
require('dotenv').config();

const config = {
apiKey: process.env.WEBLINQ_API_KEY,
baseURL: 'https://api.weblinq.dev/v1'
};

module.exports = config;

````

```python Python
# .env
WEBLINQ_API_KEY=your_api_key_here

# config.py
import os
from dotenv import load_dotenv

load_dotenv()

config = {
    'api_key': os.getenv('WEBLINQ_API_KEY'),
    'base_url': 'https://api.weblinq.dev/v1'
}
````

</CodeGroup>

### Client Setup

<CodeGroup>
```javascript Node.js
// client.js
const axios = require('axios');
const { apiKey, baseURL } = require('./config');

class WebLinqClient {
constructor() {
this.client = axios.create({
baseURL,
headers: {
'Authorization': `Bearer ${apiKey}`,
'Content-Type': 'application/json'
}
});
}

async extract(options) {
try {
const response = await this.client.post('/web/content', options);
return response.data;
} catch (error) {
this.handleError(error);
}
}

handleError(error) {
if (error.response) {
throw new Error(error.response.data.error.message);
}
throw error;
}
}

module.exports = new WebLinqClient();

````

```python Python
# client.py
import httpx
from typing import Dict, Any
from .config import config

class WebLinqClient:
    def __init__(self):
        self.client = httpx.AsyncClient(
            base_url=config['base_url'],
            headers={
                'Authorization': f"Bearer {config['api_key']}",
                'Content-Type': 'application/json'
            }
        )

    async def extract(self, options: Dict[str, Any]) -> Dict[str, Any]:
        try:
            response = await self.client.post('/web/content', json=options)
            response.raise_for_status()
            return response.json()
        except httpx.HTTPError as e:
            self.handle_error(e)

    def handle_error(self, error: httpx.HTTPError):
        if error.response:
            raise ValueError(error.response.json()['error']['message'])
        raise error

client = WebLinqClient()
````

</CodeGroup>

## Error Handling

### Custom Error Classes

<CodeGroup>
```javascript Node.js
// errors.js
class WebLinqError extends Error {
  constructor(message, code, details = {}) {
    super(message);
    this.name = 'WebLinqError';
    this.code = code;
    this.details = details;
  }
}

class RateLimitError extends WebLinqError {
constructor(message, retryAfter) {
super(message, 'rate_limit_exceeded', { retryAfter });
this.name = 'RateLimitError';
this.retryAfter = retryAfter;
}
}

class ValidationError extends WebLinqError {
constructor(message, fields) {
super(message, 'validation_error', { fields });
this.name = 'ValidationError';
this.fields = fields;
}
}

module.exports = {
WebLinqError,
RateLimitError,
ValidationError
};

````

```python Python
# errors.py
class WebLinqError(Exception):
    def __init__(self, message: str, code: str, details: dict = None):
        super().__init__(message)
        self.code = code
        self.details = details or {}

class RateLimitError(WebLinqError):
    def __init__(self, message: str, retry_after: int):
        super().__init__(message, 'rate_limit_exceeded', {'retry_after': retry_after})
        self.retry_after = retry_after

class ValidationError(WebLinqError):
    def __init__(self, message: str, fields: dict):
        super().__init__(message, 'validation_error', {'fields': fields})
        self.fields = fields
````

</CodeGroup>

### Error Handling Middleware

<CodeGroup>
```javascript Node.js
// middleware.js
const { WebLinqError, RateLimitError } = require('./errors');

class ErrorHandler {
async withRetry(fn, options = {}) {
const {
retries = 3,
baseDelay = 1000,
maxDelay = 30000
} = options;

    let lastError;

    for (let attempt = 0; attempt < retries; attempt++) {
      try {
        return await fn();
      } catch (error) {
        lastError = error;

        if (error instanceof RateLimitError) {
          await this.handleRateLimit(error);
          continue;
        }

        if (!this.shouldRetry(error)) {
          throw error;
        }

        const delay = Math.min(
          baseDelay * Math.pow(2, attempt),
          maxDelay
        );

        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    throw lastError;

}

shouldRetry(error) {
if (error instanceof WebLinqError) {
return ['timeout', 'server_error'].includes(error.code);
}
return false;
}

async handleRateLimit(error) {
const delay = error.retryAfter || 60000;
await new Promise(resolve => setTimeout(resolve, delay));
}
}

module.exports = new ErrorHandler();

````

```python Python
# middleware.py
import asyncio
from typing import Callable, Any
from .errors import WebLinqError, RateLimitError

class ErrorHandler:
    async def with_retry(
        self,
        fn: Callable[[], Any],
        retries: int = 3,
        base_delay: int = 1000,
        max_delay: int = 30000
    ) -> Any:
        last_error = None

        for attempt in range(retries):
            try:
                return await fn()
            except Exception as error:
                last_error = error

                if isinstance(error, RateLimitError):
                    await self.handle_rate_limit(error)
                    continue

                if not self.should_retry(error):
                    raise error

                delay = min(
                    base_delay * (2 ** attempt),
                    max_delay
                )

                await asyncio.sleep(delay / 1000)  # Convert to seconds

        raise last_error

    def should_retry(self, error: Exception) -> bool:
        if isinstance(error, WebLinqError):
            return error.code in ['timeout', 'server_error']
        return False

    async def handle_rate_limit(self, error: RateLimitError):
        delay = error.retry_after or 60
        await asyncio.sleep(delay)

error_handler = ErrorHandler()
````

</CodeGroup>

## Rate Limiting

### Rate Limiter Implementation

<CodeGroup>
```javascript Node.js
// rate-limiter.js
class RateLimiter {
  constructor(options = {}) {
    this.windowMs = options.windowMs || 60000;
    this.maxRequests = options.maxRequests || 60;
    this.requests = new Map();
  }

async checkLimit(key) {
const now = Date.now();
const windowStart = now - this.windowMs;

    // Clean old requests
    for (const [timestamp] of this.requests) {
      if (timestamp < windowStart) {
        this.requests.delete(timestamp);
      }
    }

    // Count requests in current window
    const requestCount = Array.from(this.requests.values())
      .filter(request => request.key === key)
      .length;

    if (requestCount >= this.maxRequests) {
      const oldestRequest = Math.min(
        ...Array.from(this.requests.keys())
      );

      const resetTime = oldestRequest + this.windowMs;
      throw new RateLimitError(
        'Rate limit exceeded',
        resetTime - now
      );
    }

    this.requests.set(now, { key });

}

async withRateLimit(key, fn) {
await this.checkLimit(key);
return fn();
}
}

module.exports = new RateLimiter();

````

```python Python
# rate_limiter.py
from time import time
from typing import Callable, Any
from .errors import RateLimitError

class RateLimiter:
    def __init__(self, window_ms: int = 60000, max_requests: int = 60):
        self.window_ms = window_ms
        self.max_requests = max_requests
        self.requests = {}

    async def check_limit(self, key: str):
        now = int(time() * 1000)
        window_start = now - self.window_ms

        # Clean old requests
        self.requests = {
            ts: req for ts, req in self.requests.items()
            if ts >= window_start
        }

        # Count requests in current window
        request_count = sum(
            1 for req in self.requests.values()
            if req['key'] == key
        )

        if request_count >= self.max_requests:
            oldest_request = min(self.requests.keys())
            reset_time = oldest_request + self.window_ms

            raise RateLimitError(
                'Rate limit exceeded',
                int((reset_time - now) / 1000)  # Convert to seconds
            )

        self.requests[now] = {'key': key}

    async def with_rate_limit(
        self,
        key: str,
        fn: Callable[[], Any]
    ) -> Any:
        await self.check_limit(key)
        return await fn()

rate_limiter = RateLimiter()
````

</CodeGroup>

## Logging

### Logger Implementation

<CodeGroup>
```javascript Node.js
// logger.js
const winston = require('winston');

const logger = winston.createLogger({
level: process.env.LOG_LEVEL || 'info',
format: winston.format.combine(
winston.format.timestamp(),
winston.format.json()
),
transports: [
new winston.transports.File({
filename: 'error.log',
level: 'error'
}),
new winston.transports.File({
filename: 'combined.log'
})
]
});

if (process.env.NODE_ENV !== 'production') {
logger.add(new winston.transports.Console({
format: winston.format.simple()
}));
}

class ApiLogger {
logRequest(req) {
logger.info('API Request', {
method: req.method,
url: req.url,
params: req.params,
headers: this.sanitizeHeaders(req.headers)
});
}

logResponse(res) {
logger.info('API Response', {
statusCode: res.statusCode,
headers: this.sanitizeHeaders(res.headers)
});
}

logError(error) {
logger.error('API Error', {
name: error.name,
message: error.message,
stack: error.stack,
code: error.code,
details: error.details
});
}

sanitizeHeaders(headers) {
const sanitized = { ...headers };
delete sanitized.authorization;
return sanitized;
}
}

module.exports = new ApiLogger();

````

```python Python
# logger.py
import logging
import json
from datetime import datetime
from typing import Dict, Any

class ApiLogger:
    def __init__(self):
        self.logger = logging.getLogger('weblinq')
        self.logger.setLevel(logging.INFO)

        # File handlers
        error_handler = logging.FileHandler('error.log')
        error_handler.setLevel(logging.ERROR)

        combined_handler = logging.FileHandler('combined.log')
        combined_handler.setLevel(logging.INFO)

        # Console handler for development
        console_handler = logging.StreamHandler()
        console_handler.setLevel(logging.INFO)

        # Formatter
        formatter = logging.Formatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )

        error_handler.setFormatter(formatter)
        combined_handler.setFormatter(formatter)
        console_handler.setFormatter(formatter)

        self.logger.addHandler(error_handler)
        self.logger.addHandler(combined_handler)
        self.logger.addHandler(console_handler)

    def log_request(self, req: Dict[str, Any]):
        self.logger.info('API Request', extra={
            'method': req.get('method'),
            'url': req.get('url'),
            'params': req.get('params'),
            'headers': self.sanitize_headers(req.get('headers', {}))
        })

    def log_response(self, res: Dict[str, Any]):
        self.logger.info('API Response', extra={
            'status_code': res.get('status_code'),
            'headers': self.sanitize_headers(res.get('headers', {}))
        })

    def log_error(self, error: Exception):
        self.logger.error('API Error', extra={
            'name': error.__class__.__name__,
            'message': str(error),
            'stack': getattr(error, '__traceback__', None),
            'code': getattr(error, 'code', None),
            'details': getattr(error, 'details', None)
        })

    def sanitize_headers(self, headers: Dict[str, str]) -> Dict[str, str]:
        sanitized = headers.copy()
        sanitized.pop('authorization', None)
        return sanitized

logger = ApiLogger()
````

</CodeGroup>

## Testing

### Test Setup

<CodeGroup>
```javascript Node.js
// test/setup.js
const { WebLinqClient } = require('../client');
const nock = require('nock');

beforeEach(() => {
nock.cleanAll();
});

afterEach(() => {
nock.cleanAll();
});

// Mock API responses
const mockExtract = (response) => {
nock('https://api.weblinq.dev/v1')
.post('/web/content')
.reply(200, response);
};

module.exports = {
mockExtract
};

````

```python Python
# tests/conftest.py
import pytest
import respx
from httpx import Response
from typing import Dict, Any

@pytest.fixture
def mock_api():
    with respx.mock(base_url='https://api.weblinq.dev/v1') as mock:
        yield mock

@pytest.fixture
def mock_extract(mock_api):
    def _mock_extract(response: Dict[str, Any]):
        mock_api.post('/web/content').mock(
            return_value=Response(200, json=response)
        )
    return _mock_extract
````

</CodeGroup>

### Example Tests

<CodeGroup>
```javascript Node.js
// test/client.test.js
const { WebLinqClient } = require('../client');
const { mockExtract } = require('./setup');

describe('WebLinqClient', () => {
const client = new WebLinqClient();

describe('extract', () => {
it('should extract content successfully', async () => {
const mockResponse = {
title: 'Test Page',
content: 'Test content'
};

      mockExtract(mockResponse);

      const result = await client.extract({
        url: 'https://example.com',
        selectors: {
          title: 'h1',
          content: '.content'
        }
      });

      expect(result).toEqual(mockResponse);
    });

    it('should handle errors properly', async () => {
      const errorResponse = {
        error: {
          code: 'validation_error',
          message: 'Invalid URL'
        }
      };

      nock('https://api.weblinq.dev/v1')
        .post('/web/content')
        .reply(400, errorResponse);

      await expect(client.extract({
        url: 'invalid-url'
      })).rejects.toThrow('Invalid URL');
    });

});
});

````

```python Python
# tests/test_client.py
import pytest
from ..client import WebLinqClient

async def test_extract_success(mock_extract):
    client = WebLinqClient()
    mock_response = {
        'title': 'Test Page',
        'content': 'Test content'
    }

    mock_extract(mock_response)

    result = await client.extract({
        'url': 'https://example.com',
        'selectors': {
            'title': 'h1',
            'content': '.content'
        }
    })

    assert result == mock_response

async def test_extract_error(mock_api):
    client = WebLinqClient()
    error_response = {
        'error': {
            'code': 'validation_error',
            'message': 'Invalid URL'
        }
    }

    mock_api.post('/web/content').mock(
        return_value=Response(400, json=error_response)
    )

    with pytest.raises(ValueError, match='Invalid URL'):
        await client.extract({
            'url': 'invalid-url'
        })
````

</CodeGroup>

## Best Practices

### Code Organization

```
project/
├── src/
│   ├── client.js
│   ├── config.js
│   ├── errors.js
│   ├── middleware.js
│   ├── rate-limiter.js
│   └── logger.js
├── test/
│   ├── setup.js
│   └── client.test.js
├── .env
├── .env.example
├── .gitignore
├── package.json
└── README.md
```

### Security Checklist

<Steps>
  <Step title="API Key Management">Store API keys securely in environment variables</Step>

{' '}
<Step title="Error Handling">Implement proper error handling and logging</Step>

{' '}
<Step title="Rate Limiting">Respect API rate limits</Step>

  <Step title="Input Validation">Validate all input before making API calls</Step>
</Steps>

### Performance Tips

<AccordionGroup>
<Accordion title="Connection Pooling" icon="network-wired">
Use connection pooling for better performance:

```javascript
const agent = new https.Agent({
  keepAlive: true,
  maxSockets: 50,
  maxFreeSockets: 10,
});

const client = axios.create({
  httpsAgent: agent,
});
```

</Accordion>

<Accordion title="Request Batching" icon="layer-group">
Batch requests when possible:

```javascript
async function batchRequests(urls, batchSize = 10) {
  const results = [];

  for (let i = 0; i < urls.length; i += batchSize) {
    const batch = urls.slice(i, i + batchSize);
    const batchResults = await Promise.all(batch.map((url) => client.extract({ url })));
    results.push(...batchResults);
  }

  return results;
}
```

</Accordion>

<Accordion title="Caching" icon="database">
Implement response caching:

```javascript
const cache = new Map();

async function withCache(key, fn) {
  if (cache.has(key)) {
    return cache.get(key);
  }

  const result = await fn();
  cache.set(key, result);
  return result;
}
```

</Accordion>
</AccordionGroup>

## Summary

<Steps>
  <Step title="Setup Environment">Configure API keys and client</Step>

{' '}
<Step title="Implement Error Handling">Add proper error handling and logging</Step>

{' '}
<Step title="Add Rate Limiting">Implement rate limiting</Step>

  <Step title="Write Tests">Add comprehensive tests</Step>
</Steps>

<Note>
  Need help with development? Check out our [example repositories](https://github.com/weblinq/examples) or contact our
  [support team](/support/contact).
</Note>
