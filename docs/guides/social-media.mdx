---
title: 'Social Media Monitoring'
description: 'Monitor social media content using WebLinq API'
---

Monitor and analyze social media content using WebLinq API workflows and structured JSON schemas.

<Note>Always respect platform terms of service and rate limits</Note>

## Advanced Profile Analysis

Extract comprehensive profile data with structured schemas and flexible text analysis:

<CodeGroup>
```javascript Structured Profile Data
async function analyzeProfile(profileUrl) {
  const apiKey = process.env.WEBLINQ_API_KEY;
  
  // Define comprehensive profile schema
  const profileSchema = {
    type: "object",
    properties: {
      profile: {
        type: "object",
        properties: {
          username: { type: "string" },
          displayName: { type: "string" },
          bio: { type: "string" },
          followers: { type: "number" },
          following: { type: "number" },
          postsCount: { type: "number" },
          verified: { type: "boolean" },
          profileImage: { type: "string", format: "uri" },
          joinDate: { type: "string" },
          location: { type: "string" },
          website: { type: "string", format: "uri" }
        }
      },
      recentPosts: {
        type: "array",
        items: {
          type: "object",
          properties: {
            content: { type: "string" },
            timestamp: { type: "string" },
            likes: { type: "number" },
            shares: { type: "number" },
            comments: { type: "number" },
            engagement: { type: "number" },
            hashtags: { type: "array", items: { type: "string" } },
            mentions: { type: "array", items: { type: "string" } },
            mediaType: { type: "string", enum: ["text", "image", "video", "link"] }
          }
        }
      },
      engagement: {
        type: "object",
        properties: {
          averageLikes: { type: "number" },
          averageComments: { type: "number" },
          engagementRate: { type: "number" },
          postFrequency: { type: "string" }
        }
      },
      topHashtags: { type: "array", items: { type: "string" } },
      topMentions: { type: "array", items: { type: "string" } }
    },
    required: ["profile", "recentPosts"]
  };

const response = await fetch('https://api.weblinq.dev/v1/web/extract-json', {
method: 'POST',
headers: {
'Authorization': `Bearer ${apiKey}`,
'Content-Type': 'application/json'
},
body: JSON.stringify({
url: profileUrl,
response_format: {
type: "json_schema",
json_schema: profileSchema
},
prompt: "Extract comprehensive social media profile information including recent posts and engagement metrics"
})
});

const data = await response.json();

if (!data.success) {
throw new Error(data.error?.message || 'Failed to extract profile data');
}

return data.data.extracted;
}

````javascript Content Strategy Analysis (Text)
async function analyzeContentStrategy(profileUrl) {
  const apiKey = process.env.WEBLINQ_API_KEY;

  // Use text response for strategic insights
  const response = await fetch('https://api.weblinq.dev/v1/web/extract-json', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      url: profileUrl,
      prompt: `Analyze this social media profile's content strategy and provide insights on:

      **Content Strategy Analysis:**
      1. **Voice & Tone**: How does this account communicate? (professional, casual, humorous, etc.)
      2. **Content Themes**: What topics and themes does this account focus on?
      3. **Audience Engagement**: How does this account interact with and build community?
      4. **Posting Strategy**: What patterns do you notice in timing, frequency, and content types?
      5. **Brand Consistency**: How consistent is the messaging and visual identity?
      6. **Growth Tactics**: What specific strategies are they using to grow their audience?
      7. **Competitive Advantages**: What makes this account stand out from others in the space?
      8. **Areas for Improvement**: What opportunities do you see for optimization?

      Provide actionable insights that could help improve social media strategy.`,
      response_format: { type: "text" }
    })
  });

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error?.message || 'Failed to analyze strategy');
  }

  return data.data.extracted;
}

```javascript Audience Persona Analysis (Text)
async function generateAudiencePersona(profileUrl) {
  const apiKey = process.env.WEBLINQ_API_KEY;

  const response = await fetch('https://api.weblinq.dev/v1/web/extract-json', {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      url: profileUrl,
      prompt: `Based on this social media profile's content, followers, and engagement patterns, create a detailed audience persona:

      **Audience Persona:**
      - **Demographics**: Age range, gender, location, income level
      - **Interests**: What topics, hobbies, and industries interest them?
      - **Pain Points**: What challenges or problems do they face?
      - **Content Preferences**: What types of content do they engage with most?
      - **Online Behavior**: How and when do they use social media?
      - **Goals & Motivations**: What are they trying to achieve?
      - **Influence Factors**: What drives their purchasing or engagement decisions?

      Write this as a comprehensive persona that could guide content creation and marketing strategies.`,
      response_format: { type: "text" }
    })
  });

  const data = await response.json();

  if (!data.success) {
    throw new Error(data.error?.message || 'Failed to generate persona');
  }

  return data.data.extracted;
}

```python Python Comprehensive Analysis
import requests

def comprehensive_social_analysis(profile_url):
    api_key = "your_api_key_here"

    # Structured data extraction
    profile_schema = {
        "type": "object",
        "properties": {
            "profile": {
                "type": "object",
                "properties": {
                    "username": {"type": "string"},
                    "displayName": {"type": "string"},
                    "bio": {"type": "string"},
                    "followers": {"type": "number"},
                    "following": {"type": "number"},
                    "verified": {"type": "boolean"}
                }
            },
            "recentPosts": {
                "type": "array",
                "items": {
                    "type": "object",
                    "properties": {
                        "content": {"type": "string"},
                        "likes": {"type": "number"},
                        "shares": {"type": "number"},
                        "hashtags": {"type": "array", "items": {"type": "string"}}
                    }
                }
            },
            "engagement": {
                "type": "object",
                "properties": {
                    "averageLikes": {"type": "number"},
                    "engagementRate": {"type": "number"}
                }
            }
        },
        "required": ["profile", "recentPosts"]
    }

    # Get structured profile data
    structured_response = requests.post(
        'https://api.weblinq.dev/v1/web/extract-json',
        headers={'Authorization': f'Bearer {api_key}', 'Content-Type': 'application/json'},
        json={
            'url': profile_url,
            'response_format': {'type': 'json_schema', 'json_schema': profile_schema},
            'prompt': 'Extract social media profile and engagement data'
        }
    )

    # Get strategic content analysis
    strategy_response = requests.post(
        'https://api.weblinq.dev/v1/web/extract-json',
        headers={'Authorization': f'Bearer {api_key}', 'Content-Type': 'application/json'},
        json={
            'url': profile_url,
            'prompt': '''Analyze this social media account for:
            - Content strategy and messaging approach
            - Target audience and demographics
            - Competitive positioning and unique value
            - Growth tactics and engagement strategies
            - Brand voice and personality
            - Opportunities for improvement

            Provide strategic insights for social media optimization.''',
            'response_format': {'type': 'text'}
        }
    )

    return {
        'profile_data': structured_response.json()['data']['extracted'],
        'strategic_analysis': strategy_response.json()['data']['extracted']
    }
}
````

</CodeGroup>

## Brand Monitoring Workflow

Comprehensive brand monitoring across social platforms:

<CodeGroup>
```javascript Brand Monitoring System
async function monitorBrandMentions(brandKeywords, platforms = ['twitter', 'linkedin', 'reddit']) {
  const apiKey = process.env.WEBLINQ_API_KEY;
  const baseUrl = 'https://api.weblinq.dev/v1';
  
  const allMentions = [];
  
  for (const platform of platforms) {
    for (const keyword of brandKeywords) {
      try {
        // Step 1: Search for brand mentions
        const searchQuery = `"${keyword}" site:${platform}.com OR site:${platform}`;
        
        const searchResponse = await fetch(`${baseUrl}/web/search`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            query: searchQuery,
            limit: 8
          })
        });

        const searchData = await searchResponse.json();

        if (!searchData.success) continue;

        // Step 2: Analyze each mention for sentiment and context
        for (const result of searchData.data.results.slice(0, 5)) {
          const mentionSchema = {
            type: "object",
            properties: {
              author: {
                type: "object",
                properties: {
                  username: { type: "string" },
                  followers: { type: "number" },
                  verified: { type: "boolean" },
                  influence: { type: "string", enum: ["low", "medium", "high"] }
                }
              },
              content: {
                type: "object",
                properties: {
                  text: { type: "string" },
                  sentiment: { type: "string", enum: ["positive", "negative", "neutral"] },
                  topics: { type: "array", items: { type: "string" } },
                  urgency: { type: "string", enum: ["low", "medium", "high", "critical"] },
                  actionRequired: { type: "boolean" }
                }
              },
              engagement: {
                type: "object",
                properties: {
                  likes: { type: "number" },
                  shares: { type: "number" },
                  comments: { type: "number" },
                  reach: { type: "number" }
                }
              },
              context: {
                type: "object",
                properties: {
                  isComplaint: { type: "boolean" },
                  isPraise: { type: "boolean" },
                  isQuestion: { type: "boolean" },
                  competitorMention": { type: "boolean" }
                }
              }
            }
          };

          const extractResponse = await fetch(`${baseUrl}/web/extract-json`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              url: result.url,
              response_format: {
                type: "json_schema",
                json_schema: mentionSchema
              },
              prompt: `Analyze this social media post mentioning "${keyword}" for sentiment, urgency, and context`
            })
          });

          // Step 3: Take screenshot for visual record
          const screenshotResponse = await fetch(`${baseUrl}/web/screenshot`, {
            method: 'POST',
            headers: {
              'Authorization': `Bearer ${apiKey}`,
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              url: result.url,
              screenshotOptions: { fullPage: false, type: 'png' }
            })
          });

          const [mentionData, screenshot] = await Promise.all([
            extractResponse.json(),
            screenshotResponse.json()
          ]);

          if (mentionData.success) {
            allMentions.push({
              keyword,
              platform,
              url: result.url,
              title: result.title,
              analyzed: mentionData.data.extracted,
              screenshot: screenshot.success ? screenshot.data.permanentUrl : null,
              foundAt: new Date().toISOString()
            });
          }

          await new Promise(resolve => setTimeout(resolve, 1500));
        }
      } catch (error) {
        console.error(`Error monitoring ${keyword} on ${platform}:`, error);
      }
    }

}

return {
keywords: brandKeywords,
platforms,
mentions: allMentions,
analysis: {
totalMentions: allMentions.length,
bySentiment: {
positive: allMentions.filter(m => m.analyzed?.content?.sentiment === 'positive'),
negative: allMentions.filter(m => m.analyzed?.content?.sentiment === 'negative'),
neutral: allMentions.filter(m => m.analyzed?.content?.sentiment === 'neutral')
},
urgentMentions: allMentions.filter(m =>
['high', 'critical'].includes(m.analyzed?.content?.urgency)
),
actionRequired: allMentions.filter(m => m.analyzed?.content?.actionRequired),
byPlatform: platforms.reduce((acc, platform) => {
acc[platform] = allMentions.filter(m => m.platform === platform);
return acc;
}, {})
}
};
}

````
</CodeGroup>

## Competitor Analysis Dashboard

Analyze competitor social media strategies:

<CodeGroup>
```javascript Competitor Analysis
async function analyzeCompetitorSocial(competitorProfiles) {
  const apiKey = process.env.WEBLINQ_API_KEY;
  const baseUrl = 'https://api.weblinq.dev/v1';

  const competitorData = [];

  for (const competitor of competitorProfiles) {
    try {
      // Extract comprehensive competitor data
      const competitorSchema = {
        type: "object",
        properties: {
          profile: {
            type: "object",
            properties: {
              name: { type: "string" },
              followers: { type: "number" },
              following: { type: "number" },
              postsPerWeek: { type: "number" },
              verified: { type: "boolean" }
            }
          },
          contentStrategy: {
            type: "object",
            properties: {
              primaryTopics: { type: "array", items: { type: "string" } },
              contentTypes: { type: "array", items: { type: "string" } },
              postingFrequency: { type: "string" },
              bestPerformingContent: { type: "array", items: { type: "string" } }
            }
          },
          engagement: {
            type: "object",
            properties: {
              averageLikes: { type: "number" },
              averageComments: { type: "number" },
              engagementRate: { type: "number" },
              topHashtags: { type: "array", items: { type: "string" } }
            }
          },
          trends: {
            type: "object",
            properties: {
              growthRate: { type: "string" },
              engagementTrend: { type: "string", enum: ["rising", "stable", "declining"] },
              contentGaps: { type: "array", items: { type: "string" } }
            }
          }
        }
      };

      const extractResponse = await fetch(`${baseUrl}/web/extract-json`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          url: competitor.url,
          response_format: {
            type: "json_schema",
            json_schema: competitorSchema
          },
          prompt: `Analyze this competitor's social media strategy, content performance, and growth trends`
        })
      });

      // Get links to recent posts for deeper analysis
      const linksResponse = await fetch(`${baseUrl}/web/links`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          url: competitor.url,
          includeExternal: false,

        })
      });

      const [competitorAnalysis, recentLinks] = await Promise.all([
        extractResponse.json(),
        linksResponse.json()
      ]);

      if (competitorAnalysis.success) {
        // Analyze recent posts for content strategy
        const postLinks = recentLinks.success ?
          recentLinks.data.links.filter(link =>
            link.url.includes('/post/') || link.url.includes('/status/')
          ).slice(0, 5) : [];

        competitorData.push({
          competitor: competitor.name,
          url: competitor.url,
          platform: competitor.platform,
          analysis: competitorAnalysis.data.extracted,
          recentPosts: postLinks,
          analyzedAt: new Date().toISOString()
        });
      }

    } catch (error) {
      console.error(`Error analyzing ${competitor.name}:`, error);
    }

    await new Promise(resolve => setTimeout(resolve, 2000));
  }

  // Generate competitive insights
  const insights = generateCompetitiveInsights(competitorData);

  return {
    competitors: competitorData,
    insights,
    summary: {
      totalCompetitors: competitorData.length,
      avgFollowers: competitorData.reduce((sum, c) =>
        sum + (c.analysis?.profile?.followers || 0), 0) / competitorData.length,
      topPerformers: competitorData
        .sort((a, b) => (b.analysis?.engagement?.engagementRate || 0) -
                       (a.analysis?.engagement?.engagementRate || 0))
        .slice(0, 3),
      opportunities: insights.contentGaps,
      threats: insights.risingCompetitors
    }
  };
}

function generateCompetitiveInsights(competitorData) {
  // Analyze patterns across competitors
  const allTopics = competitorData.flatMap(c =>
    c.analysis?.contentStrategy?.primaryTopics || []
  );

  const topicCounts = allTopics.reduce((acc, topic) => {
    acc[topic] = (acc[topic] || 0) + 1;
    return acc;
  }, {});

  return {
    commonTopics: Object.entries(topicCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 5)
      .map(([topic]) => topic),
    contentGaps: findContentGaps(competitorData),
    risingCompetitors: competitorData.filter(c =>
      c.analysis?.trends?.engagementTrend === 'rising'
    ),
    bestPractices: extractBestPractices(competitorData)
  };
}
````

</CodeGroup>

## Influencer Discovery

Find and analyze potential influencers in your niche:

<CodeGroup>
```javascript Influencer Discovery
async function discoverInfluencers(niche, platform = 'instagram', minFollowers = 10000) {
  const apiKey = process.env.WEBLINQ_API_KEY;
  const baseUrl = 'https://api.weblinq.dev/v1';
  
  // Step 1: Search for potential influencers
  const searchQuery = `${niche} influencer site:${platform}.com`;
  
  const searchResponse = await fetch(`${baseUrl}/web/search`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      query: searchQuery,
      limit: 15
    })
  });

const searchData = await searchResponse.json();

if (!searchData.success) {
throw new Error('Search failed');
}

const influencers = [];

// Step 2: Analyze each potential influencer
for (const result of searchData.data.results) {
try {
const influencerSchema = {
type: "object",
properties: {
profile: {
type: "object",
properties: {
username: { type: "string" },
displayName: { type: "string" },
bio: { type: "string" },
followers: { type: "number" },
following: { type: "number" },
postsCount: { type: "number" },
verified: { type: "boolean" },
niche: { type: "array", items: { type: "string" } }
}
},
engagement: {
type: "object",
properties: {
averageLikes: { type: "number" },
averageComments: { type: "number" },
engagementRate": { type: "number" },
recentPostsPerformance: { type: "string" }
}
},
content: {
type: "object",
properties: {
contentTypes: { type: "array", items: { type: "string" } },
postingFrequency: { type: "string" },
brandCollaborations: { type: "number" },
authenticity: { type: "string", enum: ["high", "medium", "low"] }
}
},
audience: {
type: "object",
properties: {
demographics: { type: "string" },
interests: { type: "array", items: { type: "string" } },
engagement: { type: "string", enum: ["active", "moderate", "passive"] }
}
},
collaboration: {
type: "object",
properties: {
contactInfo": { type: "string" },
rateRange: { type: "string" },
brandFit: { type: "number", minimum: 1, maximum: 10 },
availability: { type: "string", enum: ["available", "limited", "unavailable"] }
}
}
}
};

      const extractResponse = await fetch(`${baseUrl}/web/extract-json`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          url: result.url,
          response_format: {
            type: "json_schema",
            json_schema: influencerSchema
          },
          prompt: `Analyze this ${niche} influencer profile for collaboration potential, engagement quality, and audience fit`
        })
      });

      const influencerData = await extractResponse.json();

      if (influencerData.success) {
        const profile = influencerData.data.extracted;

        // Filter by minimum followers
        if (profile.profile?.followers >= minFollowers) {
          influencers.push({
            url: result.url,
            title: result.title,
            platform,
            ...profile,
            discoveredAt: new Date().toISOString(),
            searchRank: influencers.length + 1
          });
        }
      }

    } catch (error) {
      console.error(`Error analyzing influencer ${result.url}:`, error);
    }

    await new Promise(resolve => setTimeout(resolve, 1500));

}

// Rank influencers by collaboration potential
const rankedInfluencers = influencers.sort((a, b) => {
const scoreA = calculateInfluencerScore(a);
const scoreB = calculateInfluencerScore(b);
return scoreB - scoreA;
});

return {
niche,
platform,
totalFound: rankedInfluencers.length,
influencers: rankedInfluencers,
topPicks: rankedInfluencers.slice(0, 5),
insights: {
avgFollowers: rankedInfluencers.reduce((sum, inf) =>
sum + (inf.profile?.followers || 0), 0) / rankedInfluencers.length,
avgEngagement: rankedInfluencers.reduce((sum, inf) =>
sum + (inf.engagement?.engagementRate || 0), 0) / rankedInfluencers.length,
commonInterests: findCommonInterests(rankedInfluencers),
priceRanges: analyzePriceRanges(rankedInfluencers)
}
};
}

function calculateInfluencerScore(influencer) {
let score = 0;

// Engagement rate (40% weight)
const engagementRate = influencer.engagement?.engagementRate || 0;
score += (engagementRate \* 40);

// Brand fit (30% weight)
const brandFit = influencer.collaboration?.brandFit || 0;
score += (brandFit \* 3);

// Authenticity (20% weight)
const authenticity = influencer.content?.authenticity;
if (authenticity === 'high') score += 20;
else if (authenticity === 'medium') score += 10;

// Availability (10% weight)
if (influencer.collaboration?.availability === 'available') score += 10;
else if (influencer.collaboration?.availability === 'limited') score += 5;

return score;
}

````
</CodeGroup>

## Social Media Reporting

Generate comprehensive social media reports:

<CodeGroup>
```javascript Social Media Reports
async function generateSocialMediaReport(profiles, timeframe = 'monthly') {
  const apiKey = process.env.WEBLINQ_API_KEY;
  const baseUrl = 'https://api.weblinq.dev/v1';

  const reportData = [];

  for (const profile of profiles) {
    // Extract detailed analytics
    const analyticsSchema = {
      type: "object",
      properties: {
        overview: {
          type: "object",
          properties: {
            totalPosts: { type: "number" },
            totalLikes: { type: "number" },
            totalComments: { type: "number" },
            totalShares: { type: "number" },
            followerGrowth: { type: "number" },
            engagementRate: { type: "number" }
          }
        },
        topPerformingPosts: {
          type: "array",
          items: {
            type: "object",
            properties: {
              content: { type: "string" },
              likes: { type: "number" },
              engagement: { type: "number" },
              contentType: { type: "string" }
            }
          }
        },
        contentAnalysis: {
          type: "object",
          properties: {
            mostUsedHashtags: { type: "array", items: { type: "string" } },
            contentTypes: { type: "array", items: { type: "string" } },
            postingTimes: { type: "array", items: { type: "string" } },
            engagementPatterns: { type: "string" }
          }
        },
        audienceInsights: {
          type: "object",
          properties: {
            demographics: { type: "string" },
            interests: { type: "array", items: { type: "string" } },
            activeHours: { type: "array", items: { type: "string" } },
            growthTrends: { type: "string" }
          }
        }
      }
    };

    const analyticsResponse = await fetch(`${baseUrl}/web/extract-json`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        url: profile.url,
        response_format: {
          type: "json_schema",
          json_schema: analyticsSchema
        },
        prompt: `Extract ${timeframe} social media analytics and performance metrics for this profile`
      })
    });

    const analytics = await analyticsResponse.json();

    if (analytics.success) {
      reportData.push({
        profile: profile.name,
        platform: profile.platform,
        url: profile.url,
        analytics: analytics.data.extracted,
        reportPeriod: timeframe
      });
    }

    await new Promise(resolve => setTimeout(resolve, 1000));
  }

  // Create comprehensive report
  const reportHtml = generateSocialReportHTML(reportData, timeframe);

  // Convert to PDF
  const dataUri = 'data:text/html;base64,' + Buffer.from(reportHtml).toString('base64');

  const pdfResponse = await fetch(`${baseUrl}/web/pdf`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${apiKey}`,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      url: dataUri
    })
  });

  const pdf = await pdfResponse.json();

  return {
    profiles: profiles.map(p => p.name),
    timeframe,
    reportData,
    pdfUrl: pdf.success ? pdf.data.permanentUrl : null,
    summary: {
      totalProfiles: reportData.length,
      avgEngagement: calculateAverageEngagement(reportData),
      topPerformer: findTopPerformer(reportData),
      insights: generateSocialInsights(reportData)
    },
    generatedAt: new Date().toISOString()
  };
}

function generateSocialReportHTML(reportData, timeframe) {
  return `
    <html>
      <head>
        <title>Social Media Report - ${timeframe}</title>
        <style>
          body { font-family: Arial, sans-serif; margin: 40px; line-height: 1.6; }
          h1 { color: #1da1f2; border-bottom: 3px solid #1da1f2; padding-bottom: 10px; }
          h2 { color: #14171a; margin-top: 30px; }
          .profile-section { margin: 30px 0; padding: 20px; border: 1px solid #e1e8ed; border-radius: 8px; }
          .metric { display: inline-block; margin: 10px 20px 10px 0; padding: 10px; background: #f7f9fa; border-radius: 4px; }
          .metric-value { font-size: 1.2em; font-weight: bold; color: #1da1f2; }
          .top-post { margin: 15px 0; padding: 15px; background: #f7f9fa; border-left: 4px solid #1da1f2; }
          ul { margin: 10px 0; }
          li { margin: 5px 0; }
        </style>
      </head>
      <body>
        <h1>Social Media Performance Report</h1>
        <p><strong>Report Period:</strong> ${timeframe}</p>
        <p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>

        ${reportData.map(profile => `
          <div class="profile-section">
            <h2>${profile.profile} (${profile.platform})</h2>

            <div class="metrics-grid">
              <div class="metric">
                <div>Total Posts</div>
                <div class="metric-value">${profile.analytics?.overview?.totalPosts || 'N/A'}</div>
              </div>
              <div class="metric">
                <div>Total Likes</div>
                <div class="metric-value">${profile.analytics?.overview?.totalLikes || 'N/A'}</div>
              </div>
              <div class="metric">
                <div>Engagement Rate</div>
                <div class="metric-value">${profile.analytics?.overview?.engagementRate || 'N/A'}%</div>
              </div>
              <div class="metric">
                <div>Follower Growth</div>
                <div class="metric-value">${profile.analytics?.overview?.followerGrowth || 'N/A'}</div>
              </div>
            </div>

            <h3>Top Performing Content</h3>
            ${profile.analytics?.topPerformingPosts?.map(post => `
              <div class="top-post">
                <p><strong>Content:</strong> ${post.content}</p>
                <p><strong>Likes:</strong> ${post.likes} | <strong>Type:</strong> ${post.contentType}</p>
              </div>
            `).join('') || '<p>No data available</p>'}

            <h3>Content Insights</h3>
            <p><strong>Top Hashtags:</strong> ${profile.analytics?.contentAnalysis?.mostUsedHashtags?.join(', ') || 'N/A'}</p>
            <p><strong>Content Types:</strong> ${profile.analytics?.contentAnalysis?.contentTypes?.join(', ') || 'N/A'}</p>
            <p><strong>Best Posting Times:</strong> ${profile.analytics?.contentAnalysis?.postingTimes?.join(', ') || 'N/A'}</p>
          </div>
        `).join('')}
      </body>
    </html>
  `;
}
````

</CodeGroup>

## Real-time Trend Monitoring

Monitor social media trends and viral content:

<CodeGroup>
```javascript Trend Monitoring
async function monitorTrends(platforms = ['twitter', 'tiktok', 'instagram']) {
  const apiKey = process.env.WEBLINQ_API_KEY;
  const baseUrl = 'https://api.weblinq.dev/v1';
  
  const trends = [];
  
  for (const platform of platforms) {
    try {
      // Search for trending content
      const searchResponse = await fetch(`${baseUrl}/web/search`, {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: `trending viral ${platform} today`,
          limit: 10
        })
      });

      const searchData = await searchResponse.json();

      if (!searchData.success) continue;

      for (const result of searchData.data.results.slice(0, 5)) {
        const trendSchema = {
          type: "object",
          properties: {
            trend: {
              type: "object",
              properties: {
                topic: { type: "string" },
                hashtags: { type: "array", items: { type: "string" } },
                description: { type: "string" },
                viralityScore: { type: "number", minimum: 1, maximum: 10 },
                category: { type: "string" },
                demographics: { type: "string" }
              }
            },
            metrics: {
              type: "object",
              properties: {
                estimatedReach: { type: "number" },
                engagementLevel: { type: "string", enum: ["low", "medium", "high", "viral"] },
                growthRate: { type: "string" },
                peakTime: { type: "string" }
              }
            },
            relevance: {
              type: "object",
              properties: {
                brandOpportunity: { type: "number", minimum: 1, maximum: 10 },
                riskLevel: { type: "string", enum: ["low", "medium", "high"] },
                actionable: { type: "boolean" },
                timeframe: { type: "string" }
              }
            }
          }
        };

        const trendResponse = await fetch(`${baseUrl}/web/extract-json`, {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${apiKey}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            url: result.url,
            response_format: {
              type: "json_schema",
              json_schema: trendSchema
            },
            prompt: `Analyze this trending social media content for virality, engagement, and brand opportunity`
          })
        });

        const trendData = await trendResponse.json();

        if (trendData.success) {
          trends.push({
            platform,
            url: result.url,
            title: result.title,
            ...trendData.data.extracted,
            discoveredAt: new Date().toISOString()
          });
        }

        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    } catch (error) {
      console.error(`Error monitoring trends on ${platform}:`, error);
    }

}

return {
platforms,
trends: trends.sort((a, b) =>
(b.trend?.viralityScore || 0) - (a.trend?.viralityScore || 0)
),
opportunities: trends.filter(t =>
t.relevance?.brandOpportunity >= 7 && t.relevance?.riskLevel !== 'high'
),
alerts: trends.filter(t =>
t.metrics?.engagementLevel === 'viral' || t.trend?.viralityScore >= 8
),
summary: {
totalTrends: trends.length,
viralContent: trends.filter(t => t.metrics?.engagementLevel === 'viral').length,
highOpportunity: trends.filter(t => t.relevance?.brandOpportunity >= 8).length,
platforms: platforms.reduce((acc, platform) => {
acc[platform] = trends.filter(t => t.platform === platform).length;
return acc;
}, {})
}
};
}

```
</CodeGroup>

## API Coverage for Social Media

<AccordionGroup>
<Accordion title="🔍 Search API">
Discover social media mentions, influencers, and trending content across platforms.
</Accordion>

<Accordion title="🤖 Extract JSON API">
Extract structured data from social profiles, posts, and engagement metrics using JSON schemas.
</Accordion>

<Accordion title="🔗 Links API">
Monitor social media pages for new posts and discover viral content as it emerges.
</Accordion>

<Accordion title="📸 Screenshot API">
Capture visual proof of social media mentions, posts, and trending content for reports.
</Accordion>

<Accordion title="📋 PDF API">
Generate professional social media reports, influencer profiles, and trend analyses.
</Accordion>

<Accordion title="📄 Markdown API">
Extract clean text content from social posts for sentiment analysis and content research.
</Accordion>
</AccordionGroup>

<Warning>Always respect platform terms of service and rate limits when monitoring social media sites.</Warning>

<Tip>**Social Media Pro Tip**: Combine search for discovery, extract-json with schemas for structured analysis, screenshot for visual documentation, and PDF for professional reporting. This creates a complete social media intelligence system.</Tip>

<AccordionGroup>
<Accordion title="📊 JSON Schema for Social Media">
- **CRM integration** for lead tracking and customer data
- **Analytics dashboards** with consistent metrics
- **Automated monitoring** and alert systems
- **Competitive benchmarking** with standardized data
- **Performance tracking** over time
</Accordion>

<Accordion title="📝 Text Response for Social Media">
- **Strategic insights** and content recommendations
- **Audience persona development** and targeting
- **Brand voice analysis** and consistency checks
- **Competitive intelligence** and positioning
- **Creative content ideas** and campaign concepts
</Accordion>
</AccordionGroup>
```
